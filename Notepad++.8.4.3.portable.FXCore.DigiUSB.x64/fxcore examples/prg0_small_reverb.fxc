; Default program 0
;
; Small reverb
; mono in/two channel out
;
; pot0 = reverb time
; pot1 = diffusion
; pot2 = LP filter
; pot3 = reverb level
; pot4 = not used
; pot5 = not used

.mem    ap1         420           ; all-pass block 1
.mem    ap2         867           ; all-pass block 2
.mem    ap3         1578          ; all-pass block 3
.mem    ap4         390           ; all-pass block 4
.mem    apc1        3402          ; loop all-pass 1
.mem    apc2        2202          ; loop all-pass 2
.mem    dc          7678          ; loop delay

.equ    kapi        0.65          ; all-pass coefficients
.equ    kap         0.6

.equ    fs          32768         ; sample rate
.equ    freq        0.45          ; LFO frequency in Hz
.equ    pi          3.14159       ; pi
.equ    lfo_f_coeff (2*pi*freq)/fs ; calculate the LFO coefficient, SEE NOTE

                                  ; NOTE: The datasheet states the equation is:
                                  ; (2^31 - 1)*(2*pi*freq)/fs
                                  ; but we are missing the (2^31 - 1)
                                  ; this is because by default the equation solver in the assembler assumes all
                                  ; calculated values for .creg, .sreg and .mreg directives resolve to +/-1.0 and
                                  ; will scale them automatically by 2^31-1
                                  ; if you were to directly enter a vlaue like 0x12345678 then you would
                                  ; just do it like: .sreg lfo0_f 0x12345678
                                  ; note that the equation solver assumption of +/-1.0 can be overridden
                                  ; by appending .i to the .sreg for .sreg.i meaning force an integer evaluation
.sreg   lfo0_f      lfo_f_coeff   ; write it to the SFR for LFO 0

.rn     temp        r9
.rn     krt         r10           ; reverb time
.rn     kdiff       r11           ; input AP diffusion coefficients
.rn     lp          r12           ; low pass 
.rn     kfl         r13           ; lp coeff
.rn     klevel      r14           ; reverb level

cpy_cs    r0, pot0
log2      r0                      ; log2 into acc32
sra       acc32, 1                ; /2 for sq root
exp2      acc32                   ; back to linear
multri    acc32, 0.8              ; range 0 to 0.8
wrdld     r0, 0.1*32767           ; put 0.1 in r0
adds      acc32, r0               ; range 0.1 to 0.9
cpy_cc    krt, acc32

cpy_cs    r0, pot1
multri    r0, 0.2
addsi     acc32, 0.5
cpy_cc    kdiff, acc32

cpy_cs    acc32, pot2
multri    acc32, 0.805
wrdld     r0, 28737               ; put 0.877... into r0
subs      r0, acc32
cpy_cc    kfl, acc32

cpy_cs    klevel, pot3_smth

; get input to to first string of APs
cpy_cs    acc32, in0
sra       acc32, 1
apra      kdiff, ap1#
aprb      kdiff, ap1
apra      kdiff, ap2#
aprb      kdiff, ap2
apra      kdiff, ap3#
aprb      kdiff, ap3
apa       kapi, ap4#
apa       -kapi, ap4
cpy_cc    temp, acc32             ; put to the side for now
;
rddel     acc32, dc#
subs      acc32, lp               ; lp filter so: acc32 = input - lp
multrr    acc32, kfl              ; acc32*K2
adds      acc32, lp               ; acc32+lp
cpy_cc    lp, acc32               ; write back to lp
multrr    krt, acc32              ; multiply by reverb time
adds      acc32, temp             ; add in input all-pass
apa       kap, apc1#
apb       -kap, apc1
apa       kap, apc2#
apb       -kap, apc2
wrdel     dc, acc32
;
;
clracc64                          ; clear the 64-bit accumulator
machid    0.8, dc                 ; add in taps from delays
machid    0.7, dc+4315
machid    0.6, dc#
sat64     acc32                   ; copy upper 32 bits to acc32 and saturate
multrr    acc32, klevel           ; multiply by level
cpy_cs    temp, in0
adds      temp, acc32             ; add wet to dry
cpy_sc    out0, acc32             ; and write to the left DAC output
cpy_sc    out1, acc32             ; and write to the right DAC output
;
;
xor       acc32, acc32
ori       acc32, 50
cpy_cc    r15, acc32
chr       lfo0|sin,dc+100
wrdel     dc+200, acc32
