; Default program 5
;
; Chorus
; Mono in/out
;
; pot0 = rate
; pot1 = depth
; pot2 = level
; pot3 = 
; pot4 = 
; pot5 =  

.equ    fs          48000
.equ    flow        .2
.equ    fhigh       10
.equ    pi          3.14159
.equ    clow        (2^31 - 1) * (2*pi*flow)/fs
.equ    chigh       (2^31 - 1) * (2*pi*fhigh)/fs
.equ    cdiff       chigh - clow

.mem    delay       1024

.rn     temp        r0
.rn     voice1      r1
.rn     voice2      r2
.rn     voice3      r3
.rn     bright      r4

cpy_cs  temp, pot0_smth           ; read in frequency control pot
wrdld   acc32, cdiff.u            ; load difference between low and high frequency
ori     acc32, cdiff.l
multrr  temp, acc32               ; pot0 * cdiff
cpy_cc  temp, acc32
wrdld   acc32, clow.u             ; load low freq coeff
ori     acc32, clow.l
adds    acc32, temp               ; add low freq
cpy_sc  lfo0_f, acc32             ; write to lfo0 frequency control

cpy_cs  temp, pot1_smth           ; read in depth control pot
wrdld   acc32, 400
multrr  temp, acc32
cpy_cc  r15, acc32

cpy_cs  temp, in0
wrdel   delay, temp

; voice 1
chr     lfo0|sin delay+1400
cpy_cc  voice1, acc32

; voice 2
chr     lfo0|cos delay+256
cpy_cc  voice2, acc32

; voice 3
chr     lfo0|sin|neg delay+16
cpy_cc  voice3, acc32

; voice 4
chr     lfo0|cos|neg delay+768

; sum the voices
adds    acc32, voice3
adds    acc32, voice2
adds    acc32, voice1

; get effects level pot and scale effect
cpy_cs  temp, pot2_smth
multrr  acc32, temp

; add in dry
cpy_cs  temp, in0
adds    acc32, temp

; write it
cpy_sc  out0, acc32
cpy_sc  out1, acc32


; The PWM value becomes updated every 256 samples translating to a
; PWM frequency of 125Hz @32k with 8 bit resolution.
; While this is not exactly a high resolution PWM it might still
; good enough for generating basic control voltages in some applications.
; For driving the LEDs in this case it is perfectly enough.
cpy_cs    acc32, samplecnt        ; Get the sample counter
andi      acc32, 0xFF             ; Mask b[7:0]
jnz       acc32, doPWM            ;

; Reload new PWM value from LFO0_s into "bright"
cpy_cs    temp, lfo0_s            ; read in sin wave ranges -1.0 to +1.0 (well, almost)
sra       temp, 1                 ; /2 to +/- 1/2
addsi     acc32, 0.5              ; ranges 0 to 1
sra       acc32, 23               ; shift the PWM value in place
cpy_cc    bright, acc32           ; save it

doPWM:
; Performing the decrement prior to driving the LED makes sure
; that the LED can go completly off.
addi      bright, -1              ; suntract 1 from on time
cpy_cc    bright, acc32           ; Save updated "bright"
xor       acc32, acc32            ; Clear acc32 for the LED off case
jneg      bright, doLED           ;
ori       acc32, 1                ; Set acc32[0] for the LED on case

doLED:
set       user0|0, acc32           ; set the usr1 output per the acc32 LSB