; Default program 12
;
; Rotary speaker plus small reverb
;
; mono in (in0) stereo out (out0 and out1)
;
; rotary controls:
; pot0 : slow speed
; pot1 : fast speed
; pot2 : acceleration
; pot3 : horn/drum balance
; pot4 : mic distance
; pot5 : not used
;
; reverb controls
; pot0 : reverb time
; pot1 : diffusion
; pot2 : LP filter
; pot3 : reverb level
; pot4 : not used
; pot5 : not used
;
; switch controls
; s0 : select rotary (0) or reverb (1) pot control
; s1 : select slow (0) or fast (1) speed
;
; lfos
; lfo0 : horn
; lfo1 : drum
;
.rn       slowf          r14
.rn       fastf          r13
.rn       currf          r12
.rn       accel          r11
.rn       rotary_l       r10
.rn       rotary_r       r9
.rn       drumlevel      r8
.rn       hornlevel      r7
.rn       micdistance    r6
.rn       bright         r3
.rn       temp2          r2
.rn       temp1          r1
.rn       temp           r0
;
; rotary mregs
.rn       lxn1           mr0
.rn       lxn2           mr1
.rn       lyn1           mr3
.rn       lyn2           mr4
.rn       hxn1           mr5
.rn       hxn2           mr6
.rn       hyn1           mr7
.rn       hyn2           mr8
;
; reverb mregs
.rn       krt            mr9  ; reverb time
.rn       kdiff          mr10 ; input AP diffusion coefficients
.rn       lpl            mr11 ; low pass register left
.rn       lpr            mr12 ; low pass register right
.rn       kfl            mr13 ; lp coeff
.rn       klevel         mr14 ; reverb level
;
; mregs for holding pot values to do "capture"
; rotary
.rn       pot_slow       mr15
.rn       pot_fast       mr16
.rn       pot_acc        mr17
.rn       pot_bal        mr18
.rn       pot_mic        mr19
; reverb
.rn       pot_rt         mr20
.rn       pot_diff       mr21
.rn       pot_lp         mr22
.rn       pot_lvl        mr23
;
; calculations and constants
.equ      fs             48000 ; sample rate, if you change this then filter values below need recalculated
.equ      slowlow        0.5
.equ      slowhigh       2.0
.equ      fastlow        5.0
.equ      fasthigh       10.0
.equ      dhratio        0.85
.equ      accelmin       0.000005
.equ      accelmax       0.00005
.equ      acceldiff      accelmax-accelmin
.equ      accelmini      accelmin * (2^31 - 1)
.equ      acceldiffi     acceldiff * (2^31 - 1)
; calculate lfo coefficients
.equ      pi             3.14159
.equ      slow           (2^31 - 1) * (2*pi*slowlow)/fs
.equ      shigh          (2^31 - 1) * (2*pi*slowhigh)/fs
.equ      sdiff          shigh - slow
.equ      flow           (2^31 - 1) * (2*pi*fastlow)/fs
.equ      fhigh          (2^31 - 1) * (2*pi*fasthigh)/fs
.equ      fdiff          fhigh - flow
; 2-pole xover values fc = 800hz
; low-pass - note scaled by 0.5
.equ      a0l            0.0000841 * (2^31-1)
.equ      a1l            0.000168 * (2^31-1)
.equ      a2l            0.0000841 * (2^31-1)
.equ      b1l            0.98149 * (2^31-1)
.equ      b2l            -0.48183 * (2^31-1)
; high-pass - note scaled by 0.5
.equ      a0h            0.490829 * (2^31-1)
.equ      a1h            -0.98166 * (2^31-1)
.equ      a2h            0.490829 * (2^31-1)
.equ      b1h            0.98149 * (2^31-1)
.equ      b2h            -0.48183 * (2^31-1)
;
; reverb values
.equ      kapi           0.65
.equ      kap            0.6
;
; threshold value to use pot rather than saved value
.equ      thresh         0.05
;
; memory blocks for rotary
.mem      horndel        57
.mem      drumdel        53
;
; memory blocks for reverb
.mem      apl1           420
.mem      apl2           867
.mem      apl3           1578
.mem      apl4           390
.mem      apr1           450
.mem      apr2           909
.mem      apr3           1630
.mem      apr4           576
.mem      apcl1          3402
.mem      apcl2          2202
.mem      dcl            7678
.mem      apcr1          3167
.mem      apcr2          2009
.mem      dcr            7353
;
;
; since this program has 2 different control sets, one for rotary and
; one for reverb we need to preload some reasonable settings for both as
; we do not know what the user will start up as
;
; most are just mid rang for their values, do this after all calculations
; rotary registers
.creg     slowf          (sdiff/2 + slow)/(2^31 - 1) 
.creg     fastf          (fdiff/2 + flow)/(2^31 - 1) 
.creg     currf          (sdiff/2 + slow)/(2^31 - 1) 
.creg     accel          (acceldiff/2 + accelmin)
.creg     drumlevel      0.5
.creg     hornlevel      0.5
.creg     micdistance    0.5
;
; also for pot capture registers, set all to mid point
.mreg     pot_slow       0.5
.mreg     pot_fast       0.5
.mreg     pot_acc        0.5
.mreg     pot_bal        0.5
.mreg     pot_mic        0.5
; reverb
.mreg     pot_rt         0.5
.mreg     pot_diff       0.5
.mreg     pot_lp         0.5
.mreg     pot_lvl        0.25
;
; reverb registers
.mreg     krt            0.45     ; reverb time
.mreg     kdiff          0.35     ; input AP diffusion coefficients
.mreg     kfl            0.4745   ; lp coeff
.mreg     klevel         0.25     ; reverb level
;
; prepare pot values
; if s0 is low pots control rotary, if high they control reverb
cpy_cs    temp, switch
andi      temp, 0x0001
jnz       acc32, pot_rev
; since we are here pots control rotary functions, check if the difference
; betwen the current setting and the last setting is within threshold, if
; so then update the mreg
;
cpy_cs    temp, pot0
cpy_cm    temp1, pot_slow
subs      temp, temp1             ; pot-stored value
abs       acc32                   ; |pot-stored value|
addsi     acc32, -thresh          ; |pot-stored value| - threshold
jgez      acc32, fast_chk         ; jump if difference is greater than threshold
cpy_mc    pot_slow, temp          ; copy pot value to pot_slow register
;
fast_chk:
cpy_cs    temp, pot1
cpy_cm    temp1, pot_fast
subs      temp, temp1
abs       acc32
addsi     acc32, -thresh
jgez      acc32, acc_chk          ; jump if difference is greater than threshold
cpy_mc    pot_fast, temp          ; copy pot value to pot_slow register
;
acc_chk:
cpy_cs    temp, pot2
cpy_cm    temp1, pot_acc
subs      temp, temp1
abs       acc32
addsi     acc32, -thresh
jgez      acc32, bal_chk          ; jump if difference is greater than threshold
cpy_mc    pot_acc, temp           ; copy pot value to pot_slow register
;
bal_chk:
cpy_cs    temp, pot3
cpy_cm    temp1, pot_bal
subs      temp, temp1
abs       acc32
addsi     acc32, -thresh
jgez      acc32, mic_chk          ; jump if difference is greater than threshold
cpy_mc    pot_bal, temp           ; copy pot value to pot_slow register
;
mic_chk:
cpy_cs    temp, pot4
cpy_cm    temp1, pot_mic
subs      temp, temp1
abs       acc32
addsi     acc32, -thresh
jgez      acc32, calc_rotary      ; jump if difference is greater than threshold
cpy_mc    pot_mic, temp           ; copy pot value to pot_slow register
;
;
calc_rotary:
; pot0 - slow speed
cpy_cm    temp, pot_slow
wrdld     acc32, sdiff.u
ori       acc32, sdiff.l
multrr    temp, acc32
cpy_cc    temp, acc32
wrdld     acc32, slow.u
ori       acc32, slow.l
adds      temp, acc32
cpy_cc    slowf, acc32
; repeat for fast speed pot1
cpy_cm    temp, pot_fast
wrdld     acc32, fdiff.u
ori       acc32, fdiff.l
multrr    temp, acc32
cpy_cc    temp, acc32
wrdld     acc32, flow.u
ori       acc32, flow.l
adds      temp, acc32
cpy_cc    fastf, acc32
; fast and slow calculations done
; acceleration calculation
cpy_cm    temp, pot_acc
wrdld     acc32, acceldiffi.u     ; load in difference to multiply by pot
ori       acc32, acceldiffi.l
multrr    temp, acc32
cpy_cc    temp, acc32             ; put to the side
wrdld     acc32, accelmini.u      ; load minimum value
ori       acc32, accelmini.l
adds      acc32, temp             ; add them up
cpy_cc    accel, acc32
; balance
cpy_cm hornlevel, pot_bal
wrdld     acc32, 0x7fff
subs      hornlevel, acc32
cpy_cc    drumlevel, acc32
; mic distance
cpy_cm    micdistance, pot_mic
jmp       do_rotary
;
; reverb pots
pot_rev:
cpy_cs    temp, pot0
cpy_cm    temp1, pot_rt
subs      temp, temp1
abs       acc32
addsi     acc32, -thresh
jgez      acc32, diff_chk         ; jump if difference is greater than threshold
cpy_mc    pot_rt, temp            ; copy pot value to pot_slow register
;
diff_chk:
cpy_cs    temp, pot1
cpy_cm    temp1, pot_diff
subs      temp, temp1
abs       acc32
addsi     acc32, -thresh
jgez      acc32, lp_chk           ; jump if difference is greater than threshold
cpy_mc    pot_diff, temp          ; copy pot value to pot_slow register
;
lp_chk:
cpy_cs    temp, pot2
cpy_cm    temp1, pot_lp
subs      temp, temp1
abs       acc32
addsi     acc32, -thresh
jgez      acc32, lvl_chk          ; jump if difference is greater than threshold
cpy_mc    pot_lp, temp            ; copy pot value to pot_slow register
;
lvl_chk:
cpy_cs    temp, pot3
cpy_cm    temp1, pot_lvl
subs      temp, temp1
abs       acc32
addsi     acc32, -thresh
jgez      acc32, calc_rev         ; jump if difference is greater than threshold
cpy_mc    pot_lvl, temp           ; copy pot value to pot_slow register
;
calc_rev:
; reverb time
cpy_cm    temp, pot_rt            ; read pot0 into r0
log2      r0                      ; log2 into acc32
sra       acc32, 1                ; /2 for sq root
exp2      acc32                   ; back to linear
multri    acc32, 0.8              ; range 0 to 0.8
wrdld     temp, 0.1*32767         ; put 0.1 in r0
adds      acc32, temp             ; range 0.1 to 0.9
cpy_mc    krt, acc32              ; save as krt
;
; diffusion
cpy_cm    temp, pot_diff
multri    temp, 0.7
cpy_mc    kdiff, acc32            ;input AP Ks from 0 to 0.7
;
; coeff for simple 1 pole low pass
; y[n] = (x[n] - y[n-1])*k1 + y[n-1]
cpy_cm    acc32, pot_lp           ; read in pot2
multri    acc32, 0.805
wrdld     temp, 28737             ; put 0.877... into r0
subs      temp, acc32
cpy_mc    kfl, acc32
;
cpy_cm    acc32, pot_lvl
cpy_mc    klevel, acc32
;
do_rotary:
; read switch state to decide on which one
cpy_cs    temp, switch            ; read in the switch sfr
andi      temp, 0x0002            ; only keep S1
jnz       acc32, gofast           ; if high want fast speed
cpy_cc    acc32, slowf
jmp loadlfo                       ; jump to load op

gofast: 
cpy_cc    acc32, fastf

loadlfo: 
subs      acc32, currf            ; target - current
multrr    accel, acc32            ; *acceleration
adds      acc32, currf            ; + current speed
cpy_cc    currf, acc32
cpy_sc    lfo0_f, acc32
wrdld     temp, dhratio*32767     ; drum always slower
multrr    acc32, temp
cpy_sc    lfo1_f, acc32
; lfo speeds loaded
;
; read input, filter and write to delay lines
; 2-pole low pass
clracc64
cpy_cm    temp, lyn2
wrdld     acc32, b2l.u
ori       acc32, b2l.l
machrr    acc32, temp
cpy_cm    temp, lyn1
wrdld     acc32, b1l.u
ori       acc32, b1l.l
machrr    acc32, temp
cpy_mc    lyn2, temp              ; save y[n-1] to y[n-2]
cpy_cm    temp, lxn2
wrdld     acc32, a2l.u
ori       acc32, a2l.l
machrr    acc32, temp
cpy_cm    temp, lxn1
wrdld     acc32, a1l.u
ori       acc32, a1l.l
machrr    acc32, temp
cpy_mc    lxn2, temp              ; save x[n-1] to x[n-2]
cpy_cs    temp, in0
wrdld     acc32, a0l.u
ori       acc32, a0l.l
machrr    acc32, temp
cpy_mc    lxn1, temp              ; save x[n] to x[n-1]
sat64     acc32
sls       acc32, 1                ; since coeffs were scaled by 0.5 multiply by 2
cpy_mc    lyn1, acc32             ; save to y[n-1] for next time
wrdel     drumdel, acc32          ; write to drum delay
; 2-pole high pass
clracc64
cpy_cm    temp, hyn2
wrdld     acc32, b2h.u
ori       acc32, b2h.l
machrr    acc32, temp
cpy_cm    temp, hyn1
wrdld     acc32, b1h.u
ori       acc32, b1h.l
machrr    acc32, temp
cpy_mc    hyn2, temp              ; save y[n-1] to y[n-2]
cpy_cm    temp, hxn2
wrdld     acc32, a2h.u
ori       acc32, a2h.l
machrr    acc32, temp
cpy_cm    temp, hxn1
wrdld     acc32, a1h.u
ori       acc32, a1h.l
machrr    acc32, temp
cpy_mc    hxn2, temp              ; save x[n-1] to x[n-2]
cpy_cs    temp, in0
wrdld     acc32, a0h.u
ori       acc32, a0h.l
machrr    acc32, temp
cpy_mc    hxn1, temp              ; save x[n] to x[n-1]
sat64     acc32
sls       acc32, 1                ; since coeffs were scaled by 0.5 multiply by 2
cpy_mc    hyn1, acc32             ; save to y[n-1] for next time
wrdel     horndel, acc32          ; write to horn delay
;
; at this point the input has been filtered through the xover
; and written to the proper delay lines. Now modulate the lines with
; a chorus and use that to also modulate the amplitude.
; Since horn goes CCW we want to hear it from left first then right so
; the left is modulated by COS as it leads SIN so right is SIN
;
wrdld     r15, horndel!
chr       lfo0|COS, horndel
cpy_cc    temp, acc32             ; put chorused value to the side for now
cpy_cs    acc32, lfo0_c           ; get raw COS lfo
neg       acc32                   ; invert it to do mic distance
sra       acc32, 1                ; divide by 2 fso +/-0.5
addsi     acc32, 0.5              ; add 0.5 so ranges 0 to 1.0
multrr    acc32, micdistance      ; mult by mic distance
wrdld     temp1, 0x7fff           ; load 1.0 into r1
subs      temp1, acc32            ; 1.0 - scaled lfo
multrr    acc32, temp             ; multiply amplitude
multrr    acc32, hornlevel
cpy_cc    rotary_l, acc32         ; put out on left
chr       lfo0|SIN, horndel
cpy_cc    temp, acc32             ; put chorused value to the side for now
cpy_cs    acc32, lfo0_s           ; get raw SIN lfo
neg       acc32                   ; invert it to do mic distance
sra       acc32, 1                ; divide by 2 fso +/-0.5
addsi     acc32, 0.5              ; add 0.5 so ranges 0 to 1.0
multrr    acc32, micdistance      ; mult by mic distance
wrdld     temp1, 0x7fff           ; load 1.0 into r1
subs      temp1, acc32            ; 1.0 - scaled lfo
multrr    acc32, temp             ; multiply amplitude
multrr    acc32, hornlevel
cpy_cc    rotary_r, acc32         ; put out on right
;
; now the drum, opposite direction
wrdld     r15, drumdel!
chr       lfo0|COS, drumdel
cpy_cc    temp, acc32             ; put chorused value to the side for now
cpy_cs    acc32, lfo0_c           ; get raw COS lfo
neg       acc32                   ; invert it to do mic distance
sra       acc32, 1                ; divide by 2 fso +/-0.5
addsi     acc32, 0.5              ; add 0.5 so ranges 0 to 1.0
multrr    acc32, micdistance      ; mult by mic distance
wrdld     temp1, 0x7fff           ; load 1.0 into r1
subs      temp1, acc32            ; 1.0 - scaled lfo
multrr    acc32, temp             ; multiply amplitude
multrr    acc32, drumlevel
adds      rotary_r, acc32         ; add to right
cpy_cc    rotary_r, acc32
chr       lfo0|SIN, drumdel
cpy_cc    temp, acc32             ; put chorused value to the side for now
cpy_cs    acc32, lfo0_s           ; get raw SIN lfo
neg       acc32                   ; invert it to do mic distance
sra       acc32, 1                ; divide by 2 fso +/-0.5
addsi     acc32, 0.5              ; add 0.5 so ranges 0 to 1.0
multrr    acc32, micdistance      ; mult by mic distance
wrdld     temp1, 0x7fff           ; load 1.0 into r1
subs      temp1, acc32            ; 1.0 - scaled lfo
multrr    acc32, temp             ; multiply amplitude
multrr    acc32, drumlevel
adds      rotary_l, acc32         ; add to left
cpy_cc    rotary_l, acc32
;
; reverb, inputs in rotary_l and rotary_r
sra       rotary_l, 1
cpy_cm    temp, kdiff
apra      temp, apl1#
aprb      temp, apl1
apra      temp, apl2#
aprb      temp, apl2
apra      temp, apl3#
aprb      temp, apl3
apa       kapi, apl4#
apa       -kapi, apl4
cpy_cc    temp2, acc32            ; put to the side for now
;
rddel     acc32, dcr#
cpy_cm    temp, lpl
subs      acc32, temp             ; lp filter so: acc32 = input - lp1
cpy_cm    temp1, kfl
multrr    acc32, temp1            ; acc32*K2
adds      acc32, temp             ; acc32+lp1
cpy_mc    lpl, acc32              ; write back to lp1
cpy_cm    temp, krt
multrr    temp, acc32             ; multiply by reverb time
adds      acc32, temp2            ; add in input all-pass
apa       kap, apcl1#
apb       -kap, apcl1
apa       kap, apcl2#
apb       -kap, apcl2
wrdel     dcl, acc32
;
sra rotary_r, 1
cpy_cm    temp, kdiff
apra      temp, apr1#
aprb      temp, apr1
apra      temp, apr2#
aprb      temp, apr2
apra      temp, apr3#
aprb      temp, apr3
apa       kapi, apr4#
apa       -kapi, apr4
cpy_cc    temp2, acc32            ; put to the side for now
;
rddel     acc32, dcl#
cpy_cm    temp, lpr
subs      acc32, temp             ; lp filter so: acc32 = input - lp1
cpy_cm    temp1, kfl
multrr    acc32, temp1            ; acc32*K2
adds      acc32, temp             ; acc32+lp1
cpy_mc    lpr, acc32              ; write back to lp1
cpy_cm    temp, krt
multrr    temp, acc32             ; multiply by reverb time
adds      acc32, temp2            ; add in input all-pass
apa       kap, apcr1#
apb       -kap, apcr1
apa       kap, apcr2#
apb       -kap, apcr2
wrdel     dcr, acc32
;
clracc64                          ; clear the 64-bit accumulator
machid    0.8, dcl                ; add in taps from delays
machid    0.7, dcl#
machid    0.6, dcr#
sat64     acc32                   ; copy upper 32 bits to acc32 and saturate
cpy_cm    temp, klevel            ; read mix level
multrr    acc32, temp             ; multiply by level
adds      rotary_l, acc32         ; add wet to dry
cpy_sc    out0, acc32             ; and write to the left DAC output
;
clracc64                          ; clear the 64-bit accumulator
machid    0.8, dcr                ; add in taps from delays
machid    0.7, dcr#
machid    0.6, dcl#
sat64     acc32                   ; copy upper 32 bits to acc32 and saturate
multrr    acc32, temp             ; multiply by level
adds      rotary_r, acc32         ; add wet to dry
cpy_sc    out1, acc32             ; and write to the left DAC output

; show horn LFO on usr0 LED
; The PWM value becomes updated every 256 samples translating to a
; PWM frequency of 125Hz @32k with 8 bit resolution.
; While this is not exactly a high resolution PWM it might still
; good enough for generating basic control voltages in some applications.
; For driving the LEDs in this case it is perfectly enough.
cpy_cs    acc32, samplecnt        ; Get the sample counter
andi      acc32, 0xFF             ; Mask b[7:0]
jnz       acc32, doPWM            ;

; Reload new PWM value from LFO0_s into "bright"
cpy_cs    temp, lfo0_s            ; read in sin wave ranges -1.0 to +1.0 (well, almost)
sra       temp, 1                 ; /2 to +/- 1/2
addsi     acc32, 0.5              ; ranges 0 to 1
sra       acc32, 23               ; shift the PWM value in place
cpy_cc    bright, acc32           ; save it

doPWM:
; Performing the decrement prior to driving the LED makes sure
; that the LED can go completly off.
addi      bright, -1              ; subtract 1 from on count
cpy_cc    bright, acc32           ; Save updated "bright"
xor       acc32, acc32            ; Clear acc32 for the LED off case
jneg      bright, doLED           ;
ori       acc32, 1                ; Set acc32[0] for the LED on case

doLED:
set       user0|0, acc32          ; set the usr1 output per the acc32 LSB

